#lang racket
(require 2htdp/universe 2htdp/image)

(define W 400)
(define H 200)
(define F (- H 20))

(struct keys (left right up) #:transparent)

(struct player (x y Vx Vy model inputs state) #:transparent)

(define (player-left p) (keys-left (player-inputs p)))
(define (player-right p) (keys-right (player-inputs p)))
(define (player-up p) (keys-up (player-inputs p)))

(define-syntax-rule (set-key p k bool)
  (struct-copy
   player p
   [inputs (struct-copy keys (player-inputs p) [k bool])]))

(define-syntax-rule (add p var val)
  (struct-copy player p [var val]))

(define ((press val) p key)
  (cond
    [(key=? key "left") (set-key p left val)]
    [(key=? key "right") (set-key p right val)]
    [(key=? key "up") (set-key p up val)]))

(define (horiz-socd p)
  (match (player-inputs p)
    [(keys #t _ #f) -1]
    [(keys #f _ #t) 1]
    [else 0]))

(define (vert-socd p)
  (match (player-inputs p)
    [(keys _ #t _) 1]
    [else 0]))

(define (move p)
  (case (player-state p)
    [("stand")
     (case (player-up p)
       [(#t)
        (struct-copy player p
         [Vx (* 4 (horiz-socd p))]
         [Vy 6]
         [state "jump"])]
       [else
        (let ([p (struct-copy
                  player p
                  [Vx (* 2 (horiz-socd p))])])
          (add p x (player-Vx p)))])]
    [("jump")
     (if (and (>= (player-y p) F) (<= (player-Vy p) 0))
         (struct-copy
          player p [y F] [Vy 0] [state "stand"])
         (add (add p y (- (player-Vy p)))
              Vy -1))]))



